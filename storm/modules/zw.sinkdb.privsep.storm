// Name of the dictionary key used to store the SinkDB HTTPS API key
$apiKeyName = "zw.sinkdb:https-apikey"

// Name of the dictionary key to store the SinkDB tag prefix
$tagPrefixKeyName = "zw.sinkdb:tag-prefix"

// Get the SinkDB HTTPS API key
// Args: n/a
// Returns: str (the API key)
function getApiKey() {
    // see if the user has their own key set
    $apikey = $lib.user.vars.get($apiKeyName)
    if ($apikey) {
        return($apikey)
    }

    // no user key, check for global
    $apikey = $lib.globals.get($apiKeyName)
    if ($apikey) {
        return($apikey)
    }

    // no key in either, bail
    $lib.exit("SinkDB HTTPS API key is not set. Use zw.sinkdb.setup.apikey to set one.")
}

// Set the SinkDB HTTPS API key
// Args:
//  - key (str): the API key to save
//  - user (bool): if true, key will be stored to user vars instead of globals
// Returns: n/a
function setApiKey(key, user) {
    if ($user) {
        $lib.user.vars.set($apiKeyName, $key)
    } else {
        $lib.globals.set($apiKeyName, $key)
    }
}

// Get the SinkDB tag prefix
// Args: n/a
// Returns: str (the tag prefix)
function getTagPrefix() {
    return($lib.globals.get($tagPrefixKeyName, default=rep.sinkdb))
}

// Set the SinkDB tag prefix
// Args:
//  - prefix (str): the tag prefix to save
// Returns: n/a
function setTagPrefix(prefix) {
    ($ok, $norm) = $lib.trycast(syn:tag:part, $prefix)
    if (not $ok) {
        $lib.warn("failed to set tag prefix, invalid value: {s}", s=$prefix)
        return($lib.null)
    }

    $lib.globals.set($tagPrefixKeyName, $prefix)
}

// Make an API call to SinkDB
// Args
//   - $querystr (str): Query string to append to the POST body (which this function will add the API key to)
// Returns: prim (JSON dictionary) or $lib.false
function makeSinkdbApiCall(querystr, asof) {
    $cachedData = $lib.jsonstor.cacheget("zw.sinkdb.http", $querystr, $asof)
    if ($cachedData) {
        if $lib.debug { $lib.print("using cached data for http query: {s}", s=$querystr) }
        return($cachedData)
    }

    $body = $lib.str.format("api_key={k}&{b}", k=$getApiKey(), b=$querystr)

    $resp = $lib.inet.http.post("https://sinkdb-api.abuse.ch/api/v1/", headers=({"content-type": "application/x-www-form-urlencoded"}), body=$body)
    if ($resp.code != 200) { return($lib.false) }

    $j = $resp.json()
    $ret = $lib.jsonstor.cacheset("zw.sinkdb.http", $querystr, $j)
    if $lib.debug { $lib.print("wrote http query cache data for {s}: {r}", s=$querystr, r=$ret) }

    return($j)
}

// Get the proper meta:source node for SinkDB
// Args: n/a
// Returns: meta:source node
function getMetaSource() {
    [ meta:source=$modconf.source :name="sinkdb" ]
    return($node)
}

// Model the response for a sinkdb entry
// Args:
//   - $node: node to model tags on
//   - $data: dict of data from SinkDB
// Returns: n/a
function modelLookupResponse(node, data) {
    ($ok_s, $src) = $lib.trycast(syn:tag:part, $data.source)
    ($ok_c, $class) = $lib.trycast(syn:tag:part, $data.classification)
    if (not ($ok_s and $ok_c)) {
        $lib.warn("failed to model {ioc}, couldn't norm {s} or {c}", ioc=$data.indicator, s=$data.source, c=$data.classification)
        return()
    }

    $type = $data.type
    $ts = $lib.time.parse($data.date_added, "%Y-%m-%d %H:%M:%S UTC")
    $now = $lib.time.now()
    $srcnode = $getMetaSource()

    $prefix = $getTagPrefix()

    $tagsToApply = ([$src, $lib.str.concat(class., $class), $lib.str.concat(type., $type)])
    if ($data.expose_org = 1) { $tagsToApply.append(has_operator) }
    if ($data.expose_vend = 1) { $tagsToApply.append(expose.vendor) }
    if ($data.lea_only = 1) { $tagsToApply.append(expose.lea) }

    $tags = ([])
    for $t in $tagsToApply {
        $tags.append($lib.str.join('.', ($prefix, $t)))
    }

    // add tags to the indicator
    // TODO: should we be removing things that are no longer true, or allow the analyst to derive the current state based on the timestamps?
    yield $node | { for $t in $tags {
        if ($t.endswith($src)) {[+#$t=($ts,$now)]}
        else {[+#$t=$now]}
    } }

    // add edge to the meta:source node
    [ <(seen)+ { yield $srcnode }]

    fini { return() }
}

// Model the exported data from SinkDB. Creates nodes.
// Args:
//   - $data: dict of data from SinkDB
// Returns: n/a
function modelExportResponse(data) {
    for $d in $data {
        switch $d.type {
            "ipv4": { [inet:ipv4=$d.indicator] | $modelLookupResponse($node, $d) | yield $node }
            
            /*"ipv6": { $n = {[inet:ipv6=$d.indicator]} }
            "ipv4_range": { $n = {[inet:ipv4=$d.indicator]} }
            "ipv6_range": { $n = {[inet:ipv6=$d.indicator]} }
            "domain_soa": {
                if ($d.indicator.find("@") != $lib.null) {
                    $n = {[inet:email=$d.indicator]}
                } else {
                    $n = {[inet:fqdn=$d.indicator]}
                }
            }
            "whois_email": { $n = {[inet:email=$d.indicator]} }
            "nameserver": { $n = {[inet:fqdn=$d.indicator]} }
            "web_url": { $n = {[inet:url=$d.indicator]} }
            "web_domain": { $n = {[inet:fqdn=$d.indicator]} }
            "email_from": { $n = {[inet:email=$d.indicator]} }
            "sending_ipv4": { $n = {[inet:ipv4=$d.indicator]} }
            "sending_ipv4_range": { $n = {[inet:ipv4=$d.indicator]} }
            "web_ipv4": { $n = {[inet:ipv4=$d.indicator]} }
            "sending_ipv6": { $n = {[inet:ipv6=$d.indicator]} }
            "sending_ipv6_range": { $n = {[inet:ipv6=$d.indicator]} }
            "web_ipv6": { $n = {[inet:ipv6=$d.indicator]} }*/
        }
    }
}